# Regular Expression
import re

my_string = "purple alice@google.com, blah monkey bob@abc.com blah dishwasher"
temp = my_string.split(',')
print(temp)

for phrase in temp:
    result = re.search("(['\w\.-]+)@([\w\.-]+)", phrase)
    # re.search(pattern, string, flags=0)
    # search() ফাংশন পুরো স্ট্রিং জুড়েই খোঁজ দ্যা সার্চ করে ম্যাচিং স্ট্রিং বের করে
    print(result.group())

"""
প্যাটার্ন	বর্ণনা
A, a, 0	আলফানিউমেরিক ক্যারেক্টার, শুধুই নিজেদের ম্যাচ করে।
.	ডট চিহ্ন ডিফল্টভাবে ‘নিউ লাইন’ বাদে যেকোন ক্যারেক্টারকেই ম্যাচ করে। আর DOTALL ফ্লাগ থাকলে ‘নিউ লাইন’ও ম্যাচ করে।
^	ক্যারেট স্ট্রিংয়ের শুরুটা ম্যাচ করে। আর MULTILINE মোডে থাকলে প্রতিটা নতুন লাইনের শুরুটাও ম্যাচ করে।
$	স্ট্রিংয়ের শেষটা ম্যাচ করে। আর MULTILINE মোডে থাকলে নিউলাইনের আগের স্ট্রিংয়ের শেষটা ম্যাচ করে।
*	ab* a, ab আর a এর পরে যতগুলো bই থাকুক না কেন সবগুলোকেই ম্যাচ করবে।
+	ab+ a এর পরে যতগুলো bই থাকুক না কেন সবগুলোকেই ম্যাচ করবে কিন্তু কখনোই শুধু a কে ম্যাচ করবে না।
?	ab? হয় a কে নয়তো ab কে ম্যাচ করবে।
*?, +?, ??	*, +, ? হল লোভী টাইপের, যথাসম্ভব বেশি স্ট্রিং ম্যাচ করে। এদের লাগাম টেনে ধরার জন্যই ? কে এদের সাথে জুড়ে দেয়া হয়।
{m}	a{m} কোন স্ট্রিংয়ের ঠিক m সংখ্যক a কে ম্যাচ করবে।
{m, n}	a{m, n} কোন স্ট্রিংয়ের ঠিক m থেকে n সংখ্যক a কে ম্যাচ করবে।
{m, n}?	a{m, n}? কোন স্ট্রিংয়ের ঠিক m সংখ্যক a কে ম্যাচ করবে, n সংখ্যক নয়।
/	নরমালি স্পেশাল ক্যারেক্টারদের স্কেপ করে অথবা কোন স্পেশাল সিকুয়েন্সকে নির্দেশ করে।
[]	ক্যারেক্টারের সেট বুঝায়। যেমন: [amk] a, m অথবা k কে ম্যাচ করবে। সেটের ভিতর দুইটা ক্যারেক্টারকে - চিহ্ন দিয়ে সেপারেট করা হলে ক্যারেক্টারের রেঞ্জ বুঝায়। যেমন: [a-z] a থেকে Z পর্যন্ত যেকোন লোয়ার কেসকে ম্যাচ করবে।
(...)	ব্রাকেটের ভিতরে থাকা পুরা এক্সপ্রেশনটাই ম্যাচ করবে।
\A	শুধুমাত্র স্ট্রিংয়ের শুরুতে ম্যাচ করে।
\b	যেকোন খালি স্ট্রিং ম্যাচ করে, কিন্তু শুধুমাত্র তখনই যখন তা শুরুতে বা শেষে থাকে।
\B	যেকোন খালি স্ট্রিং ম্যাচ করে, কিন্তু শুধুমাত্র তখনই যখন তা শুরুতে বা শেষে থাকে না।
\d	শুধুমাত্র ইউনিকোড ডেসিমাল ডিজিট ম্যাচ করে।
\D	ইউনিকোড ডেসিমাল ডিজিট বাদে সব ক্যারেক্টারকে ম্যাচ করে।
\s	শুধুমাত্র ইউনিকোড হোয়াইটস্পেস ক্যারেক্টার (space, newline, return, tab) ম্যাচ করে।
\S	ইউনিকোড হোয়াইটস্পেস ক্যারেক্টার বাদে সব ক্যারেক্টারকে ম্যাচ করে।
\w	শুধুমাত্র ইউনিকোড ওয়ার্ড ক্যারেক্টার ম্যাচ করে।
\W	ইউনিকোড ওয়ার্ড ক্যারেক্টার বাদে সব ক্যারেক্টারকে ম্যাচ করে।
\Z	স্ট্রিংয়ের শেষটা ম্যাচ করে।
\t, \n, \r	যথাক্রমে ট্যাব, নিউ লাইন ও রিটার্নকে ম্যাচ করে।
"""

my_string = "purple alice@google.com, blah monkey bob@abc.com blah dishwasher"
temp = my_string.split(',')
for phrase in temp:
    result = re.match("([\w\.-]+)@([\w\.-]+)", phrase) 
    # match() ফাংশন শুধুমাত্র স্ট্রিংয়ের শুরুতে খোঁজ দ্যা সার্চ করে ম্যাচিং স্ট্রিং বের করে।
    print(result)


phone = "01710835657"
result = re.search('^(?:\+?88)?01[13-9]\d{8}$', phone)
print('bd phone ', result)

# Make a regular expression
# for validating an Email
regex = '^(\w|\.|\_|\-)+[@](\w|\_|\-|\.)+[.]\w{2,3}$'

def check(email):
 
    # pass the regular expression
    # and the string in search() method
    if(re.search(regex, email)):
        print("Valid Email")
 
    else:
        print("Invalid Email")

# Driver Code
if __name__ == '__main__':
 
    # Enter the email
    email = "ankitrai326@gmail.com"
 
    # calling run function
    check(email)
 
    email = "my.ownsite@our-earth.org"
    check(email)
 
    email = "ankitrai326.com"
    check(email)